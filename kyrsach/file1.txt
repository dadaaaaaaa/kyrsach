#include <memory.h>
#include "struct.h"
#include "input.h"
#include "matrix's.h"
#include "msg.h"
/*
void Sort(int *mas,int k)
{
	int i=0;
	int j=0;
	int l=0;
	for(i=k-1;i>=0;i--)
	{
		for(j=0;j<=i;j++)
		{
			if(mas[j]>mas[j+1]) 
			{
				l=mas[j];
				mas[j]=mas[j+1];
				mas[j+1]=l;
			}
		}
	}
}

int turbo0(int k)
{
	if(k!=2) return 0;
	else return 1;
}

int turbo1(int k)
{
	if(k==0) return 1;
	else return 2;
}

void add(int *mas,int k,int *jg,int position)
{
	int i=0;
	int j=0;
	for(i=position,j=0;i<=k+position;i++,j++)
	{
		jg[i]=mas[j];
	}
}

void portret(int *&ig,int *&jg,int **finit)//
{
	int i=0;
	int j=0;
	int k=0;
	int kk=0;
	int key=0;
	int position=0;//позиция в массиве jg, в которую надо добавлять
	int *mas=new int[num_points];
	List *list=new List[num_points];
	List *p=NULL;
	ig=new int[num_points+1];
	for(i=0;i<num_points;i++)
	{
		list[i].next=NULL;
	}
	//составление "массива", содержащего номер точки и смежные с ней (не знаю как это объяснить)
	for(i=0;i<num_finit_elements;i++)
	{
		for(j=0; j<3; j++)
		{
			key=0;
			k=finit[i][turbo0(j)];//0 0 1
			kk=finit[i][turbo1(j)];// 1 2 2
			if(k<kk)
			{
				k+=kk;
				kk=k-kk;
				k-=kk;
			}
			p=&list[k];
			while(p->next)
			{
				if(p->next->num==kk)
				{
					key=1;
					break;
				}
				p=p->next;
			}
			if(!key)
			{
				p->next = new List;
				p->next->num=kk;
				p->next->next=NULL;
			}	
		}
	}
	//составление массива ig
	ig[0]=0;
	for(i=0; i<num_points; i++)
	{
		k=0;
		p=&list[i];
		while(p=p->next)
		{
			k++;
		}
		ig[i+1]=ig[i]+k;
	}
	jg=new int[ig[i]-1];
	//составление массива jg
	for(i=0;i<num_points;i++)
	{
		k=0;
		key=0;
		p=&list[i];
		while(p=p->next)
		{
			mas[k]=p->num;
			k++;
			key=1;
		}
		if(key)
		{
			Sort(mas,--k);//сортировка
			add(mas,k,jg,position);//добавляет в jg
			position+=k+1;
		}
	}
}

void particular_decision(double **point,double *x,int *point_in_area)
{
	int i=0;
	for(i=0;i<num_points;i++)
	{
		x[i]=decision(point[i][0],point[i][1],point_in_area[i]);
	}
}

int prog()
{
	int i=0;
	int key=0;
	double **point=NULL;
	int **finit=NULL;
	double **gamma_betta=NULL;
	int *finit_in_area=NULL;
	int **boards=NULL;
	int *point_in_area=NULL;
	int *ig=NULL;
	int *jg=NULL;
	double *di=NULL;
	double *ggl=NULL;
	double *ggu=NULL;	
	double *prav_vector=NULL;
	double *x=NULL;
	double *tr=NULL;
	key=input(point,finit,gamma_betta,finit_in_area,boards,point_in_area);
	if(key==2) 
	{
		cout << ("Error. Number of points or number of finit functions <=0");
		return 1;
	}
	else
	{
		if(key==1)
		{
			cout << ("Error. Can not consider input parametrs\n");
			return 1;
		}
	}
	x=new double[num_points];
	tr=new double[num_points];
	portret(ig,jg,finit);
	di=new double[num_points];
	prav_vector=new double[num_points];
	for(i=0;i<num_points;i++)
	{
		di[i]=0;
		prav_vector[i]=0;
		x[i]=0;
	}	
	ggu=new double[ig[num_points]-1];
	ggl=new double[ig[num_points]-1];
	for(i=0;i<ig[num_points];i++)
	{
		ggu[i]=0;
		ggl[i]=0;
	}
	global_matrix(finit,point,ggl,ggu,di,prav_vector,ig,jg,gamma_betta,finit_in_area,boards);



	ofstream file12("di.txt");
	for(i=0;i<num_points;i++)
	{
		file12 << di[i] << "\n";
	}
	file12.close();
	ofstream file13("ig.txt");
	for(i=0;i<num_points+1;i++)
	{
		file13 << ig[i] << "\n";
	}
	file13.close();
	ofstream file14("ggl.txt");
	for(i=0;i<ig[num_points];i++)
	{
		file14 << ggl[i] << "\n";
	}
	file14.close();
	ofstream file15("ggu.txt");
	for(i=0;i<ig[num_points];i++)
	{
		file15 << ggu[i] << "\n";
	}
	file15.close();
	ofstream file16("pr.txt");
	for(i=0;i<num_points;i++)
	{
		file16 << prav_vector[i] << "\n";
	}
	file16.close();
	ofstream file17("jg.txt");
	for(i=0;i<ig[num_points];i++)
	{
		file17 << jg[i] << "\n";
	}
	file17.close();



	LU(ig,jg,di,ggl,ggu);
	msg(ig,jg,di,ggl,ggu,prav_vector,x);
	ofstream file11("1.txt");
	for(i=0;i<num_points;i++)
	{
		file11 << x[i] << "\n";
	}
	file11.close();
	particular_decision(point,tr,point_in_area);
	ofstream file18("true.txt");
	for(i=0;i<num_points;i++)
	{
		file18 << tr[i] << "\n";
	}
	file18.close();
	return 0;
}
*/#include <iostream>
#include <fstream>

using namespace std;

int num_points=0;//количество точек
int num_finit_elements=0;//количество труегольников
int num_areas=0;
int num_boards=0;

int input(double **&point,int **&finit,double **&gamma_betta,int *&finit_in_area,int **&boards,int *&point_in_area)
{
	int i=0;
	int j=0;
	ifstream _file("coords.txt");
	if(!_file.is_open())
	{
		_file.close();
		return 1;
	}
	_file >> num_points;
	if(num_points<=0)
	{
		_file.close();
		return 2;
	}
	point=new double*[num_points];
	for(i=0;i<num_points;i++)
	{
		point[i]=new double[2];
		for(j=0;j<2;j++)
		{
			_file >> point[i][j];
		}
	}
	_file.close();
	ifstream _file1("finit_elements.txt");
	if(!_file1.is_open())
	{
		_file1.close();
		return 1;
	}
	_file1 >> num_finit_elements;
	if(num_finit_elements<=0)
	{
		_file.close();
		return 2;
	}
	finit=new int*[num_finit_elements];
	for(i=0;i<num_finit_elements;i++)
	{
		finit[i]=new int[3];
		for(j=0;j<3;j++)
		{
			_file1 >> finit[i][j];
		}
	}
	_file1.close();
	ifstream _file2("areas.txt");
	if(!_file2.is_open())
	{
		_file2.close();
		return 1;
	}
	_file2 >> num_areas;
	if(num_areas<=0)
	{
		_file.close();
		return 2;
	}
	gamma_betta=new double*[num_areas];
	finit_in_area=new int[num_finit_elements];
	for(i=0;i<num_areas;i++)
	{
		gamma_betta[i]=new double[2];
		for(j=0;j<2;j++)
		{
			_file2 >> gamma_betta[i][j]; 
		}
	}
	for(i=0;i<num_finit_elements;i++)
	{
		_file2 >> finit_in_area[i];
	}
	_file2.close();
	ifstream _file3("board.txt");
	if(!_file3.is_open())
	{
		_file3.close();
		return 1;
	}
	_file3 >> num_boards;
	boards=new int*[num_boards];
	for(i=0;i<num_boards;i++)
	{
		boards[i]=new int[4];
		for(j=0;j<5;j++)
		{
			_file3 >> boards[i][j];
		}
	}
	_file3.close();
	ifstream _file4("point_in_area.txt");
	if(!_file4.is_open())
	{
		_file4.close();
		return 1;
	}
	point_in_area=new int[num_points];
	for(i=0;i<num_points;i++)
	{
		_file4 >> point_in_area[i];
	}
	_file4.close();
	return 0;
}#include "test.h"

//
//double L1(double *p2,double *p3,double *p,double det)
//{
//	return ((p2[0]*p3[1]-p3[0]*p2[1]+(p2[1]-p3[1])*p[0]+(p3[0]-p2[0])*p[1])/det);
//}
//
//double L2(double *p1,double *p3,double *p,double det)
//{
//	return ((p3[0]*p1[1]-p1[0]*p3[1]+(p3[1]-p1[1])*p[0]+(p1[0]-p3[0])*p[1])/det);
//}
//
//double L3(double *p1,double *p2,double *p,double det)
//{
//	return ((p1[0]*p2[1]-p2[0]*p1[1]+(p1[1]-p2[1])*p[0]+(p2[0]-p1[0])*p[1])/det);
//}

double lyambda(int k)
{
	double l=0;

	if(!k) return 10;
	else return 1;
}

double mes_G(double *x,double *y)
{
	return (sqrt((y[0]-x[0])*(y[0]-x[0])+(y[1]-x[1])*(y[1]-x[1])));
}

void matrix_mass(double *p1,double *p2,double *p3,double gamma,double **matr_mass,double *local_vector_pr,int num_of_area)//матрица масс
{
	int i=0;
	int j=0;
	double det=(p2[0]-p1[0])*(p3[1]-p1[1])-(p3[0]-p1[0])*(p2[1]-p1[1]);
	double mnoz=fabs(det)/24;
	double *f=new double[3];
	double mnoz2=mnoz*gamma;
	f[0]=mnoz*func(p1[0],p1[1],num_of_area);
	f[1]=mnoz*func(p2[0],p2[1],num_of_area);
	f[2]=mnoz*func(p3[0],p3[1],num_of_area);	
	local_vector_pr[0]=2*f[0]+f[1]+f[2];
	local_vector_pr[1]=f[0]+2*f[1]+f[2];
	local_vector_pr[2]=f[0]+f[1]+2*f[2];
	for(i=0;i<3;i++)
	{
		for(j=0;j<3;j++)
		{
			if(i==j)
			{
				matr_mass[i][j]=2*mnoz2;
			}
			else
			{
				matr_mass[i][j]=mnoz2;
			}
		}
	}
}


void matrix_rigidity(double *p1,double *p2,double *p3,double **matr_rigidity,int k)
{
	int i=0;
	int j=0;
	double coeff=0;
	double det=(p2[0]-p1[0])*(p3[1]-p1[1])-(p3[0]-p1[0])*(p2[1]-p1[1]);
	double *p12=new double[2];
	double *p23=new double[2];
	double *p31=new double[2];
	for(i=0;i<2;i++)
	{
		p12[i]=(p1[i]+p2[i])/2;
		p23[i]=(p2[i]+p3[i])/2;
		p31[i]=(p3[i]+p1[i])/2;
	}
	double alpha[3][3]={	(p2[1]-p3[1]), (p3[0]-p2[0]),
							(p3[1]-p1[1]), (p1[0]-p3[0]),
							(p1[1]-p2[1]), (p2[0]-p1[0])
	};
	coeff=lyambda(k)*fabs(det)/2;
	matr_rigidity[0][0]=coeff*(alpha[0][0]/det*alpha[0][0]/det+alpha[0][1]/det*alpha[0][1]/det);
	matr_rigidity[0][1]=coeff*(alpha[0][0]/det*alpha[1][0]/det+alpha[0][1]/det*alpha[1][1]/det);
	matr_rigidity[0][2]=coeff*(alpha[0][0]/det*alpha[2][0]/det+alpha[0][1]/det*alpha[2][1]/det);
	matr_rigidity[1][0]=coeff*(alpha[1][0]/det*alpha[0][0]/det+alpha[1][1]/det*alpha[0][1]/det);
	matr_rigidity[1][1]=coeff*(alpha[1][0]/det*alpha[1][0]/det+alpha[1][1]/det*alpha[1][1]/det);
	matr_rigidity[1][2]=coeff*(alpha[1][0]/det*alpha[2][0]/det+alpha[1][1]/det*alpha[2][1]/det);
	matr_rigidity[2][0]=coeff*(alpha[2][0]/det*alpha[0][0]/det+alpha[2][1]/det*alpha[0][1]/det);
	matr_rigidity[2][1]=coeff*(alpha[2][0]/det*alpha[1][0]/det+alpha[2][1]/det*alpha[1][1]/det);
	matr_rigidity[2][2]=coeff*(alpha[2][0]/det*alpha[2][0]/det+alpha[2][1]/det*alpha[2][1]/det);
}

void local_matrix(int num_of_finit_element, int **finit,double ** point, double **local_matr,double *local_vector_pr,double **gamma_betta,int *finit_in_area)
{
	int i=0;
	int j=0;
	int k=finit[num_of_finit_element][0];
	int l=finit[num_of_finit_element][1];
	int m=finit[num_of_finit_element][2];
	double **matr_mass=new double*[3];
	double **matr_rigidity=new double*[3];
	for(i=0;i<3;i++)
	{
		matr_mass[i]=new double[3];
		matr_rigidity[i]=new double[3];
	}
	matrix_mass(point[k],point[l],point[m],gamma_betta[finit_in_area[num_of_finit_element]][0],matr_mass,local_vector_pr,finit_in_area[num_of_finit_element]);
	matrix_rigidity(point[k],point[l],point[m],matr_rigidity,finit_in_area[num_of_finit_element]);//и еще параметры
	for(i=0;i<3;i++)
	{
		for(j=0;j<3;j++)
		{
			local_matr[i][j]=matr_mass[i][j]+matr_rigidity[i][j];
		}
	}
}

int regarg_boards(int *current_board,double **a,double *b,double **points,double betta)
{
	double coeff=0;
	if(current_board[3]==1)//первые краевые
	{
		return 0;
	}
	else
	{
		if(current_board[3]==2)//вторые краевые
		{
			coeff=mes_G(points[current_board[1]],points[current_board[2]])/6.0;
			//сомневаюсь
			b[0]=coeff*(2*func_board2(points[current_board[1]],current_board[4])+func_board2(points[current_board[2]],current_board[4]));
			b[1]=coeff*(func_board2(points[current_board[1]],current_board[4])+2*func_board2(points[current_board[2]],current_board[4]));
			return 1;
		}
		else//третьи краевые
		{
			coeff=betta*mes_G(points[current_board[1]],points[current_board[2]])/6;
			a[0][0]=2*coeff;
			a[0][1]=coeff;
			a[1][0]=coeff;
			a[1][1]=2*coeff;
			b[0]=coeff*(2*func_board3(points[current_board[1]],current_board[4])+func_board3(points[current_board[2]],current_board[4]));
			b[1]=coeff*(func_board3(points[current_board[1]],current_board[4])+2*func_board3(points[current_board[2]],current_board[4]));
			return 2;
		}
	}
}

void pervoe_kraevoe(int *current_board,double **points,double *ggl,double *ggu,double *di,double *prav_vector,int *ig,int *jg)
{
	int i=0;
	int kol=0;
	int lbeg;
	int lend;
	int m=0;
	di[current_board[1]]=1;
	di[current_board[2]]=1;
	prav_vector[current_board[1]]=func_board1(points[current_board[1]],current_board[4]);
	prav_vector[current_board[2]]=func_board1(points[current_board[2]],current_board[4]);
	kol=ig[current_board[1]+1]-ig[current_board[1]];
	for(i=0;i<kol;i++)
	{
		ggl[ig[current_board[1]]+i]=0;
	}
	kol=ig[current_board[2]+1]-ig[current_board[2]];
	for(i=0;i<kol;i++)
	{
		ggl[ig[current_board[2]]+i]=0;
	}

	for(i=current_board[1]+1;i<num_points;i++)
	{
		lbeg=ig[i];
		lend=ig[i+1];
		for(int p=lbeg;p<lend;p++)
		{
			if(jg[p]==current_board[1])
			{
				ggu[p]=0;
				continue;
			}
		}

	}
	for(i=current_board[2]+1;i<num_points;i++)
	{
		lbeg=ig[i];
		lend=ig[i+1];
		for(int p=lbeg;p<lend;p++)
		{
			if(jg[p]==current_board[2])
			{
				ggu[p]=0;
				continue;
			}
		}
	}
}

void global_matrix(int **finit,double **point,double *ggl,double *ggu,double *di,double *prav_vector,int *ig,int *jg,double **gamma_betta,int *finit_in_area,int **board)
{
	int i=0;
	int j=0;
	int k=0;
	int p=0;
	int ibeg=0;
	int iend=0;
	int h=0;
	int key=0;
	int kol=0;
	int *L=new int[3];
	int *L2=new int[2];
	int *K=new int[num_points/2];
	double *local_vector_pr=new double[3];
	double **local_matr=new double*[3];
	double *b=new double[2];//вектор для краевых
	double **a=new double*[2];//матрица для краевых
	for(i=0;i<2;i++)
	{
		a[i]=new double[2];
		b[i]=0;
		for(j=0;j<2;j++)
		{
			a[i][j]=0;
		}
	}
	for(i=0;i<3;i++)
	{
		local_matr[i]=new double[3];
	}
	for(k=0;k<num_finit_elements;k++)
	{
		local_matrix(k,finit,point,local_matr,local_vector_pr,gamma_betta,finit_in_area);//посчитали локальную матрицу для данного конечного элемента
		memcpy(L,finit[k],3*sizeof(double));
		//перенос локальной матрицы в глобальную//
		for(i=0; i<3; i++)
		{
			//h=0;
			ibeg=L[i];
			for(j=i+1; j<3; j++)
			{
				iend=L[j];
				if(ibeg<iend)
				{
					h=ig[iend];
					while(jg[h++]-ibeg);
					h--;
					ggl[h]+=local_matr[i][j];
					ggu[h]+=local_matr[j][i];
				}
				else
				{
					h=ig[ibeg];
					while(jg[h++]-iend);
					h--;
					ggl[h]+=local_matr[i][j];
					ggu[h]+=local_matr[j][i];					
				}
			}
			di[ibeg]+=local_matr[i][i];
		}
		//составление вектора правой части//
		for(i=0;i<3;i++)
		{
			prav_vector[L[i]]+=local_vector_pr[i];
		}
		//=================================//
	}
	for(k=0;k<num_boards;k++)
	{
		key=regarg_boards(board[k],a,b,point,gamma_betta[board[k][0]][1]);
		if(!key)
		{		
			K[p]=k;
			p++;
			continue;
		}		
		L2[0]=board[k][1];
		L2[1]=board[k][2];
		if(key==2)
		{
			for(i=0; i<2; i++)
			{
				ibeg=L2[i];
				for(j=i+1; j<2; j++)
				{
					iend=L2[j];
					if(ibeg<iend)
					{
						h=ig[iend];
						while(jg[h++]-ibeg);
						h--;
						ggl[h]+=a[i][j];
						ggu[h]+=a[j][i];
					}
					else
					{
						h=ig[ibeg];
						while(jg[h++]-iend);
						h--;
						ggl[h]+=a[i][j];
						ggu[h]+=a[j][i];					
					}
				}
				di[ibeg]+=a[i][i];
			}
		}
		for(i=0;i<2;i++)
		{
			prav_vector[L2[i]]+=b[i];
		}
		for(i=0;i<2;i++)
		{
			b[i]=0;
			for(j=0;j<2;j++)
			{
				a[i][j]=0;
			}
		}
	}
	for(i=0;i<p;i++)
	{
		pervoe_kraevoe(board[K[i]],point,ggl,ggu,di,prav_vector,ig,jg);			
	}
}

double sqr(double x)
{
	return x*x;
}

void LU(int *ig,int *jg,double *di,double *ggl,double *ggu)
{
	int i=0;
	int j=0;
	int k=0;
    int i0=0;
	int i1=0;
	int ki=0;
	int kj=0;
    double suml=0.0;
    double sumu=0.0;
    double sumd=0.0;
    for (i=0; i<num_points; i++)
    {
		i0=ig[i];
		i1=ig[i+1];
		sumd=0.0;
		for(k=i0;k<i1;k++)
		{
			j=jg[k];
			ki=i0;
			kj=ig[j];
			suml=0.0;
			sumu=0.0;
			while(ki<k)
			if (jg[kj]==jg[ki])
			{
				sumu+=ggu[ki]*ggl[kj];
				suml+=ggu[kj]*ggl[ki];
				kj++;
				ki++;
			}
			else
			{
				if (jg[kj]<jg[ki]) kj++;
				else ki++;
			}
			ggu[k]=(ggu[k]-sumu)/di[j];
			ggl[k]=ggl[k]-suml;
			sumd+=ggu[k]*ggl[k];
		}
		di[i]=di[i]-sumd;
    }
}

void multA(double *q,double *y,int *ig,int *jg,double *di,double *ggl,double *ggu)
{
	int i=0;
	int lbeg=0;
	int k=0;
	int lend=0;
	for (i=0;i<num_points;i++)
	{
		
		y[i]=di[i]*q[i];
		lbeg=ig[i];
		lend=ig[i+1];
		for (k=lbeg;k<lend;k++)
		{
			y[i]+=ggl[k]*q[jg[k]];
			y[jg[k]]+=ggu[k]*q[i];
		}
	}
}

void multAT(double *q, double *y,int *ig,int *jg,double *di,double *ggl,double *ggu)
{
	int i=0;
	int lbeg=0;
	int k=0;
	int lend=0;
	for (i=0;i<num_points;i++)
	{
		y[i]=di[i]*q[i];
		lbeg=ig[i];
		lend=ig[i+1];
		for (k=lbeg;k<lend;k++)
		{
			y[i]+=ggu[k]*q[jg[k]];
			y[jg[k]]+=ggl[k]*q[i];
		}
	}
}

void multL(double *q, double *y,int *ig,int *jg,double *di,double *ggl,double *ggu)
{
	int i=0;
	int lbeg=0;
	int k=0;
	int lend=0;
	for (i=0;i<num_points;i++)
	{	
		y[i]=di[i]*q[i];
	}
	for (i=0;i<num_points;i++)
	{
		lbeg=ig[i];
		lend=ig[i+1];
		for (k=lbeg;k<lend;k++)
		{
			y[i]+=ggl[k]*q[jg[k]];
		}
	}
}

void multLT(double *q, double *y,int *ig,int *jg,double *di,double *ggl,double *ggu)
{
	int i=0;
	int lbeg=0;
	int k=0;
	int lend=0;
	for (i=0;i<num_points;i++)
	{	
		y[i]=di[i]*q[i];
	}
	for (i=0;i<num_points;i++)
	{
		lbeg=ig[i];
		lend=ig[i+1];
		for (k=lbeg;k<lend;k++)
		{
			y[jg[k]]+=ggl[k]*q[i];
		}
	}
}

void multU(double *q, double *y,int *ig,int *jg,double *di,double *ggl,double *ggu)
{
	int i=0;
	int lbeg=0;
	int k=0;
	int lend=0;
	for (i=0;i<num_points;i++)
	{	
		y[i]=q[i];
	}
	for (i=0;i<num_points;i++)
	{
		lbeg=ig[i];
		lend=ig[i+1];
		for (k=lbeg;k<lend;k++)
		{
			y[jg[k]]+=ggu[k]*q[i];
		}
	}
}

void multUT(double *q, double *y,int *ig,int *jg,double *di,double *ggl,double *ggu)
{
	int i=0;
	int lbeg=0;
	int k=0;
	int lend=0;
	for (i=0;i<num_points;i++)
	{	
		y[i]=q[i];
	}
	for (i=0;i<num_points;i++)
	{
		lbeg=ig[i];
		lend=ig[i+1];
		for (k=lbeg;k<lend;k++)
		{
			y[i]+=ggu[k]*q[jg[k]];
		}
	}
}

void multL_1(double *q, double *y,int *ig,int *jg,double *di,double *ggl,double *ggu)
{
	int i=0;
	int lbeg=0;
	int k=0;
	int lend=0;

	for (i=0;i<num_points;i++)
	{
		lbeg=ig[i];
		lend=ig[i+1];
		y[i]=q[i];
		for (k=lbeg;k<lend;k++)
		{
			y[i]-=ggl[k]*y[jg[k]];
		}
		y[i]/=di[i];
	}
}

void multU_1T(double *q, double *y,int *ig,int *jg,double *di,double *ggl,double *ggu)
{
	int i=0;
	int lbeg=0;
	int k=0;
	int lend=0;

	for (i=0;i<num_points;i++)
	{
		lbeg=ig[i];
		lend=ig[i+1];
		y[i]=q[i];
		for (k=lbeg;k<lend;k++)
		{
			y[i]-=ggu[k]*y[jg[k]];
		}
	}
}

void multL_1T(double *q, double *y,int *ig,int *jg,double *di,double *ggl,double *ggu)
{
	int i=0;
	int lbeg=0;
	int k=0;
	int lend=0;
	for(i=0;i<num_points;i++)
	{
		y[i]=0;
	}
	for (i=num_points-1;i>-1;i--)
	{
		lbeg=ig[i];
		lend=ig[i+1];
		y[i]=q[i]-y[i];
		y[i]/=di[i];
		for (k=lbeg;k<lend;k++)
		{
			y[jg[k]]+=ggl[k]*y[i];
		}
	}
}

void multU_1(double *q, double *y,int *ig,int *jg,double *di,double *ggl,double *ggu)
{
	int i=0;
	int lbeg=0;
	int k=0;
	int lend=0;
	for(i=0;i<num_points;i++)
	{
		y[i]=0;
	}
	for (i=num_points-1;i>-1;i--)
	{
		lbeg=ig[i];
		lend=ig[i+1];
		y[i]=q[i]-y[i];
		for (k=lbeg;k<lend;k++)
		{
			y[jg[k]]+=ggu[k]*y[i];
		}
	}
}

double scalyar(double *q, double *y)
{
	int i=0;
	double scal=0.0;
	for(i=0;i<num_points;i++)
	{
		scal+=q[i]*y[i];
	}
	return scal;
}

double nev(double *prav_vector,double norma_f,double *x,int *ig,int *jg,double *di,double *ggl,double *ggu)
{
	int i=0;	
	double n=0;
	double *nevyazka=new double[num_points];
	multA(x,nevyazka,ig,jg,di,ggl,ggu);
	for(i=0;i<num_points;i++)
	{
		n+=sqr(nevyazka[i]-prav_vector[i]);
	}
	n=sqrt(n)/norma_f;
	return n;
}

void msg(int *ig,int *jg,double *di,double *ggl,double *ggu,double *prav_vector,double *x)
{
	int i=0;
	int maxiter=50000;
	double eps=1e-13;
	int j=0,exit=0;
	double nevyaz=1;
	double norma_f=0;
	double a=0.0;
	double b=0.0;
	double *r=NULL;
	double *v=NULL;
	double *z=NULL;
	double *_x=NULL;
	double *v1=NULL;
	r=new double[num_points];
	z=new double[num_points];
	v=new double[num_points];
	v1=new double[num_points];
	_x=new double[num_points];
	multA(x,v,ig,jg,di,ggl,ggu);	
	for(i=0;i<num_points;i++)
	{
		v[i]-=prav_vector[i];
		v[i]*=-1;
		norma_f+=prav_vector[i]*prav_vector[i];
	}
	norma_f=sqrt(norma_f);
	multL_1(v,r,ig,jg,di,ggl,ggu);
	multL_1T(r,v,ig,jg,di,ggl,ggu);
	multAT(v,r,ig,jg,di,ggl,ggu);
	multU_1T(r,v,ig,jg,di,ggl,ggu);	
	memcpy(r,v,num_points*sizeof(double));
	memcpy(z,v,num_points*sizeof(double));
	multU(x,_x,ig,jg,di,ggl,ggu);
	for(i=1;(i<maxiter)&&(nevyaz>eps)&&(exit==0);i++)
	{
 		a=scalyar(r,r);
		b=1/a;
		multU_1(z,v,ig,jg,di,ggl,ggu);
		multA(v,v1,ig,jg,di,ggl,ggu);
		multL_1(v1,v,ig,jg,di,ggl,ggu);
		multL_1T(v,v1,ig,jg,di,ggl,ggu);
		multAT(v1,v,ig,jg,di,ggl,ggu);
		multU_1T(v,v1,ig,jg,di,ggl,ggu);
		a/=scalyar(v1,z);
		for(j=0;j<num_points;j++)
		{
			_x[j]+=a*z[j];
			v[j]=r[j]-a*v1[j];
		}
		b*=scalyar(v,v);
		for(j=0;j<num_points;j++)
		{
			z[j]*=b;
			z[j]+=v[j];
		}
		multU_1(_x,x,ig,jg,di,ggl,ggu);
		nevyaz=nev(prav_vector,norma_f,x,ig,jg,di,ggl,ggu);
		memcpy(r,v,num_points*sizeof(double));
	}
}


/*
struct List
{
	int num;
	List *next;
};
*/#include <math.h>
double func(double x,double y,int i)
{
	if(!i) return (-20);
	else return (0);
}

double func_board1(double *x,int k)
{
	switch(k)
	{
		case 0: return x[1]*x[1];
		case 1: return x[1];
	}
	return 0;
}

double func_board2(double *x,int k)
{
	switch(k)
	{
		case 0: return 20;
		case 1: return 0;
		case 2: return (2.);
	}
	return 0;
}

double func_board3(double *x,int k)
{
	switch(k)
	{
		case 0: return (20*x[1]-27);
		case 1: return 0;
	}
	return 0;
}

double decision(double x,double y,int k)
{
	switch(k)
	{
		case 0: return (y*y);
		case 1: return 20*y-19;
	}
	return 0;
}

#include "functions.h"

double **point=NULL;
double **gamma_betta=NULL;
int **finit=NULL;
int *finit_in_area=NULL;
int **kraev=NULL;
int *point_in_area=NULL;

int *ig=NULL;
int *jg=NULL;
double *di=NULL;
double *ggl=NULL;
double *ggu=NULL;	
double *F=NULL;
double *x=NULL;
double *tr=NULL;

void portret();
void sort(int *mas,int k);
void tochnoe();
void global_matrix()

int main()
{
	int i=0;
	int key=0;
	
	if(input()){
		cout<<"vse ploho\n";
	}

	x=new double[points_num];
	tr=new double[points_num];
	di=new double[points_num];
	F=new double[points_num];

	portret();

	for(i=0;i<points_num;i++)
	{
		di[i]=0;
		F[i]=0;
		x[i]=0;
	}	
	ggu=new double[ig[points_num]-1];
	ggl=new double[ig[points_num]-1];
	for(i=0;i<ig[points_num];i++)
	{
		ggu[i]=0;
		ggl[i]=0;
	}

	global_matrix();

	LU(ig,jg,di,ggl,ggu);
	msg(ig,jg,di,ggl,ggu,F,x);



	tochnoe();

	ofstream file11("1.txt");
	for(i=0;i<points_num;i++)
	{
		file11 << x[i] << "\n";
		file11 << tr[i] << "\n";
	}
	file11.close();
	return 0;
}

void portret()//
{
	int i=0;
	int j=0;
	int k=0;
	int kk=0;
	int key=0;
	int position=0;//позиция в массиве jg, в которую надо добавлять
	int *mas=new int[points_num];
	struct List
	{
		int num;
		List *next;
	};
	List *list=new List[points_num];
	List *p=NULL;
	ig=new int[points_num+1];
	for(i=0;i<points_num;i++)
	{
		list[i].next=NULL;
	}
	//составление "массива", содержащего номер точки и смежные с ней 
	for(i=0;i<finit_elements_num;i++)
	{
		for(j=0; j<3; j++)
		{
			key=0;
			k=finit[i][(j==2)];//0 0 1
			kk=finit[i][((j!=0)+1)];// 1 2 2
			if(k<kk)
			{
				k+=kk;
				kk=k-kk;
				k-=kk;
			}
			p=&list[k];
			while(p->next)
			{
				if(p->next->num==kk)
				{
					key=1;
					break;
				}
				p=p->next;
			}
			if(!key)
			{
				p->next = new List;
				p->next->num=kk;
				p->next->next=NULL;
			}	
		}
	}
	//составление массива ig
	ig[0]=0;
	for(i=0; i<points_num; i++)
	{
		k=0;
		p=&list[i];
		while(p=p->next)
		{
			k++;
		}
		ig[i+1]=ig[i]+k;
	}
	jg=new int[ig[i]-1];
	//составление массива jg
	for(i=0;i<points_num;i++)
	{
		k=0;
		key=0;
		p=&list[i];
		while(p=p->next)
		{
			mas[k]=p->num;
			k++;
			key=1;
		}
		if(key)
		{
			sort(mas,--k);//сортировка
			int ii=0;//добавляет в jg
			int jj=0;
			for(ii=position,jj=0;ii<=k+position;ii++,jj++)
			{
				jg[ii]=mas[jj];
			}

			position+=k+1;
		}
	}
}

void sort(int *mas,int k)
{
	int i=0;
	int j=0;
	int l=0;
	for(i=k-1;i>=0;i--)
	{
		for(j=0;j<=i;j++)
		{
			if(mas[j]>mas[j+1]) 
			{
				l=mas[j];
				mas[j]=mas[j+1];
				mas[j+1]=l;
			}
		}
	}
}
void tochnoe()
{
	int i=0;
	for(i=0;i<points_num;i++)
	{
		x[i]=resh(point[i][0],point[i][1],point_in_area[i]);
	}
}


double lambda(int k)
{
	double l=0;

	if(!k) return 10;
	else return 1;
}

double mes_G(double *x,double *y)
{
	return (sqrt((y[0]-x[0])*(y[0]-x[0])+(y[1]-x[1])*(y[1]-x[1])));
}

void M_matrix(double *p1,
				 double *p2,
				 double *p3,
				 double gamma,
				 double **M_matr,
				 double *local_F,
				 int num_of_area)
{
	int i=0;
	int j=0;
	double det=(p2[0]-p1[0])*(p3[1]-p1[1])-(p3[0]-p1[0])*(p2[1]-p1[1]);
	double mnoz=fabs(det)/24;
	double *f=new double[3];
	double mnoz2=mnoz*gamma;
	f[0]=mnoz*func(p1[0],p1[1],num_of_area);
	f[1]=mnoz*func(p2[0],p2[1],num_of_area);
	f[2]=mnoz*func(p3[0],p3[1],num_of_area);	
	local_F[0]=2*f[0]+f[1]+f[2];
	local_F[1]=f[0]+2*f[1]+f[2];
	local_F[2]=f[0]+f[1]+2*f[2];
	for(i=0;i<3;i++)
	{
		for(j=0;j<3;j++)
		{
			if(i==j)
			{
				M_matr[i][j]=2*mnoz2;
			}
			else
			{
				M_matr[i][j]=mnoz2;
			}
		}
	}
}


void G_matrix(double *p1,
					 double *p2,
					 double *p3,
					 double **G_matr,
					 int k)
{
	int i=0;
	int j=0;
	double ck=0;
	double det=(p2[0]-p1[0])*(p3[1]-p1[1])-(p3[0]-p1[0])*(p2[1]-p1[1]);
	double *p12=new double[2];
	double *p23=new double[2];
	double *p31=new double[2];
	for(i=0;i<2;i++)
	{
		p12[i]=(p1[i]+p2[i])/2;
		p23[i]=(p2[i]+p3[i])/2;
		p31[i]=(p3[i]+p1[i])/2;
	}
	double alpha[3][3]={	(p2[1]-p3[1]), (p3[0]-p2[0]),
							(p3[1]-p1[1]), (p1[0]-p3[0]),
							(p1[1]-p2[1]), (p2[0]-p1[0])
	};
	ck=lambda(k)*fabs(det)/2;
	G_matr[0][0]=ck*(alpha[0][0]/det*alpha[0][0]/det+alpha[0][1]/det*alpha[0][1]/det);
	G_matr[0][1]=ck*(alpha[0][0]/det*alpha[1][0]/det+alpha[0][1]/det*alpha[1][1]/det);
	G_matr[0][2]=ck*(alpha[0][0]/det*alpha[2][0]/det+alpha[0][1]/det*alpha[2][1]/det);
	G_matr[1][0]=ck*(alpha[1][0]/det*alpha[0][0]/det+alpha[1][1]/det*alpha[0][1]/det);
	G_matr[1][1]=ck*(alpha[1][0]/det*alpha[1][0]/det+alpha[1][1]/det*alpha[1][1]/det);
	G_matr[1][2]=ck*(alpha[1][0]/det*alpha[2][0]/det+alpha[1][1]/det*alpha[2][1]/det);
	G_matr[2][0]=ck*(alpha[2][0]/det*alpha[0][0]/det+alpha[2][1]/det*alpha[0][1]/det);
	G_matr[2][1]=ck*(alpha[2][0]/det*alpha[1][0]/det+alpha[2][1]/det*alpha[1][1]/det);
	G_matr[2][2]=ck*(alpha[2][0]/det*alpha[2][0]/det+alpha[2][1]/det*alpha[2][1]/det);
}



void local_matrix(int num_of_finit_element, 
				  double **local_matr,
				  double *local_F)
{
	int i=0;
	int j=0;
	int k=finit[num_of_finit_element][0];
	int l=finit[num_of_finit_element][1];
	int m=finit[num_of_finit_element][2];
	double **M_matr=new double*[3];
	double **G_matr=new double*[3];
	for(i=0;i<3;i++)
	{
		M_matr[i]=new double[3];
		G_matr[i]=new double[3];
	}
	M_matrix(	point[k],point[l],point[m],
				gamma_betta[finit_in_area[num_of_finit_element]][0],
				M_matr,local_F,
				finit_in_area[num_of_finit_element]);
	G_matrix(	point[k],point[l],point[m],
				G_matr,
				finit_in_area[num_of_finit_element]);
	for(i=0;i<3;i++)
	{
		for(j=0;j<3;j++)
		{
			local_matr[i][j]=M_matr[i][j]+G_matr[i][j];
		}
	}
}

int uchet_kraev(int *current_kraev,
				  double **a,
				  double *b,
				  double betta)
{
	double ck=0;
	if(current_kraev[3]==1)
	{
		return 0;
	}
	else
	{
		if(current_kraev[3]==2)
		{
			ck=mes_G(point[current_kraev[1]],point[current_kraev[2]])/6.0;
			b[0]=ck*(2*func_kraev2(point[current_kraev[1]],current_kraev[4])+func_kraev2(point[current_kraev[2]],current_kraev[4]));
			b[1]=ck*(func_kraev2(point[current_kraev[1]],current_kraev[4])+2*func_kraev2(point[current_kraev[2]],current_kraev[4]));
			return 1;
		}
		else
		{
			ck=betta*mes_G(point[current_kraev[1]],point[current_kraev[2]])/6;
			a[0][0]=2*ck;
			a[0][1]=ck;
			a[1][0]=ck;
			a[1][1]=2*ck;
			b[0]=ck*(2*func_kraev3(point[current_kraev[1]],current_kraev[4])+func_kraev3(point[current_kraev[2]],current_kraev[4]));
			b[1]=ck*(func_kraev3(point[current_kraev[1]],current_kraev[4])+2*func_kraev3(point[current_kraev[2]],current_kraev[4]));
			return 2;
		}
	}
}




void pervoe_kraevoe(int *current_kraev)
{
	int i=0;
	int kol=0;
	int lbeg;
	int lend;
	int m=0;
	di[current_kraev[1]]=1;
	di[current_kraev[2]]=1;
	F[current_kraev[1]]=func_kraev1(points[current_kraev[1]],current_kraev[4]);
	F[current_kraev[2]]=func_kraev1(points[current_kraev[2]],current_kraev[4]);
	kol=ig[current_kraev[1]+1]-ig[current_kraev[1]];
	for(i=0;i<kol;i++)
	{
		ggl[ig[current_kraev[1]]+i]=0;
	}
	kol=ig[current_kraev[2]+1]-ig[current_kraev[2]];
	for(i=0;i<kol;i++)
	{
		ggl[ig[current_kraev[2]]+i]=0;
	}

	for(i=current_kraev[1]+1;i<points_num;i++)
	{
		lbeg=ig[i];
		lend=ig[i+1];
		for(int p=lbeg;p<lend;p++)
		{
			if(jg[p]==current_kraev[1])
			{
				ggu[p]=0;
				continue;
			}
		}

	}
	for(i=current_kraev[2]+1;i<points_num;i++)
	{
		lbeg=ig[i];
		lend=ig[i+1];
		for(int p=lbeg;p<lend;p++)
		{
			if(jg[p]==current_kraev[2])
			{
				ggu[p]=0;
				continue;
			}
		}
	}
}
void global_matrix()
{
	int i=0;
	int j=0;
	int k=0;
	int p=0;
	int ibeg=0;
	int iend=0;
	int h=0;
	int key=0;
	int kol=0;
	int *L=new int[3];
	int *L2=new int[2];
	int *K=new int[points_num/2];
	double *local_F=new double[3];
	double **local_matr=new double*[3];
	double *b=new double[2];//вектор для краевых
	double **a=new double*[2];//матрица для краевых
	for(i=0;i<2;i++)
	{
		a[i]=new double[2];
		b[i]=0;
		for(j=0;j<2;j++)
		{
			a[i][j]=0;
		}
	}
	for(i=0;i<3;i++)
	{
		local_matr[i]=new double[3];
	}
	for(k=0;k<finit_elements_num;k++)
	{
		local_matrix(k,local_matr,local_F);
		memcpy(L,finit[k],3*sizeof(double));
		//локальная в глобальную//
		for(i=0; i<3; i++)
		{
			//h=0;
			ibeg=L[i];
			for(j=i+1; j<3; j++)
			{
				iend=L[j];
				if(ibeg<iend)
				{
					h=ig[iend];
					while(jg[h++]-ibeg);
					h--;
					ggl[h]+=local_matr[i][j];
					ggu[h]+=local_matr[j][i];
				}
				else
				{
					h=ig[ibeg];
					while(jg[h++]-iend);
					h--;
					ggl[h]+=local_matr[i][j];
					ggu[h]+=local_matr[j][i];					
				}
			}
			di[ibeg]+=local_matr[i][i];
		}
		//правая часть//
		for(i=0;i<3;i++)
		{
			F[L[i]]+=local_F[i];
		}

	}
	for(k=0;k<num_kraev;k++)
	{
		key=uchet_kraev(kraev[k],a,b,gamma_betta[kraev[k][0]][1]);
		if(!key)
		{		
			K[p]=k;
			p++;
			continue;
		}		
		L2[0]=kraev[k][1];
		L2[1]=kraev[k][2];
		if(key==2)
		{
			for(i=0; i<2; i++)
			{
				ibeg=L2[i];
				for(j=i+1; j<2; j++)
				{
					iend=L2[j];
					if(ibeg<iend)
					{
						h=ig[iend];
						while(jg[h++]-ibeg);
						h--;
						ggl[h]+=a[i][j];
						ggu[h]+=a[j][i];
					}
					else
					{
						h=ig[ibeg];
						while(jg[h++]-iend);
						h--;
						ggl[h]+=a[i][j];
						ggu[h]+=a[j][i];					
					}
				}
				di[ibeg]+=a[i][i];
			}
		}
		for(i=0;i<2;i++)
		{
			F[L2[i]]+=b[i];
		}
		for(i=0;i<2;i++)
		{
			b[i]=0;
			for(j=0;j<2;j++)
			{
				a[i][j]=0;
			}
		}
	}
	for(i=0;i<p;i++)
	{
		pervoe_kraevoe(kraev[K[i]]);			
	}
}

double func(double x,double y,int i)
{
	if(!i) return (-20);
	else return (0);
}

double func_kraev1(double *x,int k)
{
	switch(k)
	{
		case 0: return x[1]*x[1];
		case 1: return x[1];
	}
	return 0;
}

double func_kraev2(double *x,int k)
{
	switch(k)
	{
		case 0: return 20;
		case 1: return 0;
		case 2: return (2.);
	}
	return 0;
}

double func_kraev3(double *x,int k)
{
	switch(k)
	{
		case 0: return (20*x[1]-27);
		case 1: return 0;
	}
	return 0;
}

double resh(double x,double y,int k)
{
	switch(k)
	{
		case 0: return (y*y);
		case 1: return 20*y-19;
	}
	return 0;
}

