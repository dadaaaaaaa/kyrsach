#include <iostream>
#include <cmath>
#include <map>
#include <algorithm>
using namespace std;
// Определение структуры для треугольного элемента
struct Triangle {
    int nodes[3]; // Индексы вершин
};
// Функция для вычисления локальной матрицы жесткости для треугольника
void localStiffnessMatrix(double diffCoeff, double K[3][3]) {
    K[0][0] =  2; K[0][1] = -1; K[0][2] = -1;
    K[1][0] = -1; K[1][1] =  2; K[1][2] = -1;
    K[2][0] = -1; K[2][1] = -1; K[2][2] =  2;
    
    // Умножаем на коэффициент диффузии и нормализуем
    for (int i = 0; i < 3; ++i) {
        for (int j = 0; j < 3; ++j) {
            K[i][j] *= diffCoeff / 4.0;
        }
    }
}
// Генерация разреженной матрицы в строчном формате
void assembleGlobalMatrix(Triangle* elements, int numElements, double diffCoeff, double** K, int numNodes) {
    double K_local[3][3];
    for (int e = 0; e < numElements; ++e) {
        localStiffnessMatrix(diffCoeff, K_local);
        for (int i = 0; i < 3; ++i) {
            for (int j = 0; j < 3; ++j) {
                K[elements[e].nodes[i]][elements[e].nodes[j]] += K_local[i][j];
            }
        }
    }
}
// Метод сопряженных градиентов
bool conjugateGradient(double** A, double* b, double* x, int n, int maxIter, double tol) {
    double* r = new double[n];
    double* p = new double[n];
    double* Ap = new double[n];
    // Инициализация
    for (int i = 0; i < n; ++i) {
        x[i] = 0.0; // Начальное приближение
        r[i] = b[i];
        p[i] = r[i];
    }
    double rDotOld = 0.0;
    for (int i = 0; i < n; ++i) {
        rDotOld += r[i] * r[i];
    }
    for (int k = 0; k < maxIter; ++k) {
        // A*p
        for (int i = 0; i < n; ++i) {
            Ap[i] = 0.0;
            for (int j = 0; j < n; ++j) {
                Ap[i] += A[i][j] * p[j];
            }
        }
        double alpha = rDotOld;
        double pDotAp = 0.0;
        for (int i = 0; i < n; ++i) {
            pDotAp += p[i] * Ap[i];
        }
        alpha /= pDotAp;
        // Обновление x
        for (int i = 0; i < n; ++i) {
            x[i] += alpha * p[i];
        }
        // Обновление r
        for (int i = 0; i < n; ++i) {
            r[i] -= alpha * Ap[i];
        }
        double rDotNew = 0.0;
        for (int i = 0; i < n; ++i) {
            rDotNew += r[i] * r[i];
        }
        // Проверка на сходимость
        if (sqrt(rDotNew) < tol) {
            delete[] r;
            delete[] p;
            delete[] Ap;
            return true;
        }
        double beta = rDotNew / rDotOld;
        for (int i = 0; i < n; ++i) {
            p[i] = r[i] + beta * p[i];
        }
        rDotOld = rDotNew;
    }
    delete[] r;
    delete[] p;
    delete[] Ap;
    return false;
}
int main() {
    // Пример: 4 треугольника с 4 узлами
    Triangle elements[4] = {
        {{0, 1, 2}},
        {{1, 2, 3}},
        {{0, 2, 3}},
        {{0, 1, 3}}
    };
    int numNodes = 4; // Количество узлов
    double diffCoeff = 1.0; // Коэффициент диффузии
    // Создание глобальной матрицы K
    double** K = new double*[numNodes];
    for (int i = 0; i < numNodes; ++i) {
        K[i] = new double[numNodes]();
    }
    assembleGlobalMatrix(elements, 4, diffCoeff, K, numNodes);
    
    // Вектор правой части
    double b[4] = {1, 0, 0, 0}; // Пример правой части
    double x[4]; // Решение
    // Решение СЛАУ Kx = b
    if (conjugateGradient(K, b, x, numNodes, 1000, 1e-6)) {
        cout << "Решение: ";
        for (int i = 0; i < numNodes; ++i) {
            cout << x[i] << " ";
        }
        cout << endl;
    } else {
        cout << "Не удалось найти решение." << endl;
    }
    // Освобождение памяти
    for (int i = 0; i < numNodes; ++i) {
        delete[] K[i];
    }
    delete[] K;
    return 0;
}
